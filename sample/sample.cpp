#include <conf4cpp.hpp>
#include <boost/tuple/tuple.hpp>

using namespace conf4cpp;

//
// the following code is automatically generated by conf4cpp
//
class MyConfigParser;

class MyConfig : public base_config<MyConfigParser> {
public:
    enum proto_t {
	UDP, TCP, ICMP, RTP, 
    };
    enum foo_t {
	FOO, BAR, BAZ,
    };

    MyConfig(const string& fname) : base_config<MyConfigParser>(fname) {
	foo_ = var2int(vm_["foo"]);
	bar_ = var2bool(vm_["bar"]);
	baz_ = var2string(vm_["baz"]);

	vector<var_t> poo_0_ = var2vector(vm_["poo"]);
	poo_ = boost::tuple<int,bool>(var2int(poo_0_[0]), var2bool(poo_0_[1]));

	vector<var_t> por_0_ = var2vector(vm_["por"]);
	por_ = vector<int>(por_0_.size());
	transform(por_0_.begin(), por_0_.end(), por_.begin(), &var2int);

	vector<var_t> pom_0_ = var2vector(vm_["pom"]);
	pom_ = vector<string>(pom_0_.size());
	transform(pom_0_.begin(), pom_0_.end(), pom_.begin(), &var2string);

	vector<var_t> far_0_ = var2vector(vm_["far"]);
	vector<var_t> far_0_0_ = var2vector(far_0_[0]);
	vector<string> far_0_0s_ = vector<string>(far_0_0_.size());
	transform(far_0_0_.begin(), far_0_0_.end(), far_0_0s_.begin(), &var2string);
	vector<var_t> far_0_1_ = var2vector(far_0_[1]);
	boost::tuple<int,string> far_0_1t_(var2int(far_0_1_[0]),var2string(far_0_1_[1]));
	far_ = boost::tuple<vector<string>,boost::tuple<int,string>,bool>(far_0_0s_,far_0_1t_,var2bool(far_0_[2]));
	
	hoo_ = proto_t(var2pair(vm_["hoo"]).second);

	vector<var_t> haz_0_ = var2vector(vm_["haz"]);
	haz_ = boost::tuple<foo_t, proto_t>(foo_t(var2pair(haz_0_[0]).second),proto_t(var2pair(haz_0_[1]).second));

	cout << "OK" << endl;
    }

    const vector<string>& pom() const { return pom_; }
    bool has_pom() const { return has_pom_; }

private:
    int foo_;
    bool bar_;
    string baz_;
    boost::tuple<int, bool> poo_;
    vector<int> por_;
    vector<string> pom_;
    bool has_pom_;
    boost::tuple<vector<string>,boost::tuple<int,string>,bool> far_;
    proto_t hoo_;
    boost::tuple<foo_t,proto_t> haz_;
};
struct MyConfigParser : public base_config_parser<MyConfigParser>
{
    struct keywords : symbols<string>
    {
	keywords() {
	    add
		("foo", "foo")
		("bar", "bar")
		("baz", "baz")
		("poo", "poo")
		("por", "por")
		("pom", "pom")
		("far", "far")
		("hoo", "hoo")
		("haz", "haz")
		;
	}
    };
    struct constvals : symbols<pair<int,int> >
    {
	constvals() {
	    add
		("UDP",  make_pair(0, MyConfig::UDP))
		("TCP",  make_pair(0, MyConfig::TCP))
		("ICMP", make_pair(0, MyConfig::ICMP))
		("RTP",  make_pair(0, MyConfig::RTP))
		("FOO",  make_pair(1, MyConfig::FOO))
		("BAR",  make_pair(1, MyConfig::BAR))
		("BAZ",  make_pair(1, MyConfig::BAZ))
		;
	}
    };

    MyConfigParser(value_map_t& vmap_) : base_config_parser<MyConfigParser>(vmap_) {
	timap["foo"] = TI_INT;
	timap["bar"] = TI_BOOL;
	timap["baz"] = TI_STRING;

	vector<type_t> ti_poo;
	ti_poo.push_back(TI_INT);
	ti_poo.push_back(TI_BOOL);
	timap["poo"] = ti_poo; // (int, bool)

	pair<int, type_t> ti_por(5, TI_INT);
	timap["por"] = ti_por; // int, int, int, int, int

	pair<int, type_t> ti_pom(0, TI_STRING); // string,string,string, ...
	timap["pom"] = ti_pom;

	vector<type_t> ti_far;
	pair<int, type_t> ti_far_0(0, TI_STRING);
	vector<type_t> ti_far_1;
	ti_far_1.push_back(TI_INT);
	ti_far_1.push_back(TI_STRING);
	ti_far.push_back(ti_far_0);
	ti_far.push_back(ti_far_1);
	ti_far.push_back(TI_BOOL);
	timap["far"] = ti_far;	// tuple<vector<string>,tuple<int,string>,bool>

	timap["hoo"] = ti_enum_t(0);
	vector<type_t> ti_haz;
	ti_haz.push_back(ti_enum_t(1));  // FOO
	ti_haz.push_back(ti_enum_t(0));  // PROTO
	timap["haz"] = ti_haz;
    }
};

int main(int argc, char* args[])
{
    if (argc < 2) {
	cout << "no input file.\n";
	return -1;
    }

    MyConfig conf(args[1]);

    return 0;
}
